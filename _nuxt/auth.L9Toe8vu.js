import{a0 as E,I as P,a1 as R,a2 as T,a3 as F,a4 as O,a5 as L,T as U,a6 as $,q as S,a7 as q,C as z,a8 as p,a9 as B,aa as j,ab as H,k as M,ac as I,y as x,z as A}from"./entry.2mjX4fi1.js";const K=r=>r==="defer"||r===!1;function G(...r){var w;const o=typeof r[r.length-1]=="string"?r.pop():void 0;typeof r[0]!="string"&&r.unshift(o);let[t,s,e={}]=r;if(typeof t!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof s!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const a=U(),c=s,m=()=>null,y=()=>a.isHydrating?a.payload.data[t]:a.static.data[t];e.server=e.server??!0,e.default=e.default??m,e.getCachedData=e.getCachedData??y,e.lazy=e.lazy??!1,e.immediate=e.immediate??!0,e.deep=e.deep??E.deep,e.dedupe=e.dedupe??"cancel";const _=()=>![null,void 0].includes(e.getCachedData(t));if(!a._asyncData[t]||!e.immediate){(w=a.payload._errors)[t]??(w[t]=null);const l=e.deep?P:R;a._asyncData[t]={data:l(e.getCachedData(t)??e.default()),pending:P(!_()),error:T(a.payload._errors,t),status:P("idle")}}const n={...a._asyncData[t]};n.refresh=n.execute=(l={})=>{if(a._asyncDataPromises[t]){if(K(l.dedupe??e.dedupe))return a._asyncDataPromises[t];a._asyncDataPromises[t].cancelled=!0}if((l._initial||a.isHydrating&&l._initial!==!1)&&_())return Promise.resolve(e.getCachedData(t));n.pending.value=!0,n.status.value="pending";const f=new Promise((i,u)=>{try{i(c(a))}catch(b){u(b)}}).then(i=>{if(f.cancelled)return a._asyncDataPromises[t];let u=i;e.transform&&(u=e.transform(i)),e.pick&&(u=N(u,e.pick)),a.payload.data[t]=u,n.data.value=u,n.error.value=null,n.status.value="success"}).catch(i=>{if(f.cancelled)return a._asyncDataPromises[t];n.error.value=$(i),n.data.value=S(e.default()),n.status.value="error"}).finally(()=>{f.cancelled||(n.pending.value=!1,delete a._asyncDataPromises[t])});return a._asyncDataPromises[t]=f,a._asyncDataPromises[t]};const g=()=>n.refresh({_initial:!0}),D=e.server!==!1&&a.payload.serverRendered;{const l=q();if(l&&!l._nuxtOnBeforeMountCbs){l._nuxtOnBeforeMountCbs=[];const i=l._nuxtOnBeforeMountCbs;l&&(F(()=>{i.forEach(u=>{u()}),i.splice(0,i.length)}),O(()=>i.splice(0,i.length)))}D&&a.isHydrating&&(n.error.value||_())?(n.pending.value=!1,n.status.value=n.error.value?"error":"success"):l&&(a.payload.serverRendered&&a.isHydrating||e.lazy)&&e.immediate?l._nuxtOnBeforeMountCbs.push(g):e.immediate&&g(),e.watch&&L(e.watch,()=>n.refresh());const f=a.hook("app:data:refresh",async i=>{(!i||i.includes(t))&&await n.refresh()});l&&O(f)}const v=Promise.resolve(a._asyncDataPromises[t]).then(()=>n);return Object.assign(v,n),v}function N(r,o){const t={};for(const s of o)t[s]=r[s];return t}function V(r,o,t){const[s={},e]=typeof o=="string"?[{},o]:[o,t],a=z(()=>{let h=r;return typeof h=="function"&&(h=h()),p(h)}),c=s.key||B([e,typeof a.value=="string"?a.value:"",...J(s)]);if(!c||typeof c!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+c);if(!r)throw new Error("[nuxt] [useFetch] request is missing.");const m=c===e?"$f"+c:c;if(!s.baseURL&&typeof a.value=="string"&&a.value[0]==="/"&&a.value[1]==="/")throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:y,lazy:_,default:n,transform:g,pick:D,watch:v,immediate:w,getCachedData:l,deep:f,...i}=s,u=j({...H,...i,cache:typeof s.cache=="boolean"?void 0:s.cache}),b={server:y,lazy:_,default:n,transform:g,pick:D,immediate:w,getCachedData:l,deep:f,watch:v===!1?[]:[u,a,...v||[]]};let d;return G(m,()=>{var k;(k=d==null?void 0:d.abort)==null||k.call(d),d=typeof AbortController<"u"?new AbortController:{};const h=p(s.timeout);return h&&setTimeout(()=>d.abort(),h),(s.$fetch||globalThis.$fetch)(a.value,{signal:d.signal,...u})},b)}function J(r){var t;const o=[((t=p(r.method))==null?void 0:t.toUpperCase())||"GET",p(r.baseURL)];for(const s of[r.params||r.query]){const e=p(s);if(!e)continue;const a={};for(const[c,m]of Object.entries(e))a[p(c)]=p(m);o.push(a)}return o}const C=(r,o)=>{const{access:t}=Q(),e=M().public.baseURL,a=new Headers,c=`${e}${r}`;return V(c,{...o,async onRequest({request:m,options:y}){t&&a.set("Authorization","Bearer "+t),y.headers=a}},"$sC22i8rhLA")},Q=I("auth",{state:()=>({username:null,email_valid:!1,password1_valid:!1,isAuthenticated:!1,non_field_errors:!1,firstname_valid:!1,lastname_valid:!1,access:null,refresh_token:null,details:!1}),persist:!0,actions:{restEmail(){this.email_valid=!1},restPassword(){this.password1_valid=!1},async login(r,o,t){try{const s=await C("api/token/",{method:"POST",body:r});if(s.status.value==="success"){const e=s.data.value;this.username=e.first_name?e.first_name:e.username,this.access=e.access,this.refresh_token=e.refresh,this.isAuthenticated=!0,t();const a=x(),c=A();setTimeout(()=>{a.push({path:c("/")})},1e3)}if(s.status.value==="error"){this.isAuthenticated=!1;const e=s.error.value.data;this.details=e.detail?e.detail:!1,this.email_valid=e.username?e.username[0]:!1,this.password1_valid=e.password?e.password[0]:!1,o()}}catch(s){console.error("Error:",s)}},async register(r,o,t){try{const s=await C("auth/register/",{method:"POST",body:r});if(s.status.value==="success"){const e=s.data.value;this.user=e.user,o();const a=x(),c=A();setTimeout(()=>{a.push({path:c("login")})},1e3)}if(s.status.value==="error"){const e=s.error.value.data;this.non_field_errors=e.non_field_errors?e.non_field_errors[0]:!1,this.email_valid=e.email?e.email[0]:!1,this.firstname_valid=e.first_name?e.first_name[0]:!1,this.lastname_valid=e.last_name?e.last_name[0]:!1,this.password1_valid=e.password1?e.password1[0]:!1,t()}}catch(s){console.error("Error",s)}},async refresh(){try{const r=new FormData;r.append("refresh",this.refresh_token);const o=await C("api/token/refresh/",{method:"POST",body:r});if(o.status.value==="success"){const t=o.data.value;this.access=t.access,this.refresh_token=t.refresh,this.isAuthenticated=!0}o.status.value==="error"&&(this.isAuthenticated=!1)}catch(r){console.error("Error:",r)}}}});export{Q as a};
